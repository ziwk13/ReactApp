<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <title>useMemo</title>
</head>
<body>

<!--
1. React.useMemo()
  1) 계산 비용이 높은 연산의 결과를 메모이제이션(memoization)하여, 컴포넌트가 리렌더링될 때마다 불필요하게 같은 연산을 반복하지 않도록 성능을 최적화하는 훅(Hooks) 입니다.
  2) 계산이 오래 걸리는 경우 해당 계산 결과를 캐싱(caching)해 두면 리렌더링할 때 재계산을 생략할 수 있습니다.
  3) 반환할 계산 결과를 캐싱해 두는 것을 Memoization(메모이제이션)이라고 합니다.
  4) 주요 특징
    (1) 메모이제이션
      ▶︎ 의존성 배열에 명시된 값이 변경되지 않으면, 이전에 계산된 값을 재사용합니다.
    (2) 렌더링 최적화
      ▶︎ 불필요한 연산을 줄여 컴포넌트의 렌더링 성능을 향상시킵니다.
    (3) 참조 동일성 유지
      ▶︎ 객체나 배열과 같은 참조형 데이터를 useMemo로 감싸면, 리렌더링 시에도 동일한 참조를 유지할 수 있어 불필요한 자식 컴포넌트의 렌더링을 방지할 수 있습니다.


2. React.useMemo() 구문
  1) 형식
    const memoizedValue = React.useMemo(calculateValue, [dependencies])
  2) 설명
    (1) memoizedValue
      - 최초 렌더링 시 calculateValue 함수가 반환한 값입니다.
      - 리렌더링 시 의존성 배열(dependencies)에 명시된 값이 변경되지 않으면 이전에 저장된 memoizedValue를 그대로 사용합니다.
    (2) calculateValue
      - 계산 비용이 높은 연산을 수행하는 함수입니다.
      - 인자는 없고, 연산 결과를 반환합니다. 모든 타입의 값을 반환할 수 있습니다.
    (3) dependencies
      - 의존성 배열입니다. 선택 인자이지만 사실상 필수 인자입니다.
      - 의존성 배열을 전달하지 않으면, useMemo는 모든 렌더링마다 calculateValue 함수를 실행하게 되어 메모이제이션의 효과를 얻을 수 없습니다. (useMemo를 사용하지 않은 것과 같습니다.)
      - 의존성 배열을 빈 배열([])로 전달하면 컴포넌트가 처음 마운트될 때 한 번만 실행되고, 이후에는 값이 변경되지 않습니다. 마지막 렌더링에서 캐싱한 값을 반환합니다.
      - 의존성 배열에 특정 값을 넣으면 그 값이 변경될 때만 calculateValue 함수가 실행되고 반환된 값을 다시 캐싱합니다.


3. object type problem
  useEffect()의 의존성 배열에 컴포넌트에서 선언한 객체를 전달하는 경우
  해당 객체는 useMemo()를 이용해 캐싱해야 합니다.
  그렇지 않으면 객체가 가진 값의 변경이 없더라도 항상 useEffect()이 동작하는 문제가 발생합니다.
-->

<div id="root1"></div>
<script type="text/babel">

  function OverheadComp() {

    // state
    const [number1, setNumber1] = React.useState(0);
    const [number2, setNumber2] = React.useState(0);
  
    // 오래 걸리는 연산
    const operation1 = (n) => {
      for (let i = 0; i < 1999999999; i++);
      return n + 1;
    }
    const result1 = operation1(number1);

    // 일반 연산
    const operation2 = n => n + 1;

    const result2 = operation2(number2);
  
    // return
    return (
      <>
        <h3>오버헤드 연산</h3>
        <input type="number" value={number1} onChange={(e) => setNumber1(Number(e.target.value)) } />
        <div>{number1} + 1 = {result1}</div>
        <h3>일반 연산</h3>
        <input type="number" value={number2} onChange={(e) => setNumber2(Number(e.target.value)) } />
        <div>{number2} + 1 = {result2}</div>
      </>
    )
  
  
  }
  // ReactDOM.createRoot(document.getElementById('root1')).render(<OverheadComp/>)

</script>

<div id="root2"></div>
<script type="text/babel">

  function UseMemoComp() {

    // state
    const [number1, setNumber1] = React.useState(0);
    const [number2, setNumber2] = React.useState(0);
  
    // 오래 걸리는 연산
    const operation1 = (n) => {
      for (let i = 0; i < 1999999999; i++);
      return n + 1;
    }
    // 오래 걸리는 연산 결과는 useMemo()를 이용해서 캐싱해 둘 수 있다.
    // number1이 변할때만 다시 연산을 수행하도록 설정해 둔다.
    const result1 = React.useMemo(() => {
      return operation1(number1);
    }, [number1]);  // 의존 배열에 설정한 값이 변하는 경우에만 operation1() 함수를 호출 한다

    // 일반 연산
    const operation2 = n => n + 1;

    const result2 = operation2(number2);
  
    // return
    return (
      <>
        <h3>오버헤드 연산</h3>
        <input type="number" value={number1} onChange={(e) => setNumber1(Number(e.target.value)) } />
        <div>{number1} + 1 = {result1}</div>
        <h3>일반 연산</h3>
        <input type="number" value={number2} onChange={(e) => setNumber2(Number(e.target.value)) } />
        <div>{number2} + 1 = {result2}</div>
      </>
    )
  
  
  }
  ReactDOM.createRoot(document.getElementById('root2')).render(<UseMemoComp/>)

</script>

<div id="root3"></div>
<script type="text/babel">

  function ObjectTypeProblem() {

    //state
    const [sale, setSale] = React.useState(false);  // 객체 tv를 바꾸는 state 값
    const [number, setNumber] = React.useState(0);  // 객체 tv와 아무런 관계가 없는 state

    // 객체
    // - 컴포넌트 내부에서 선언한 객체는 컴포넌트가 리렌더링 될 때마다 항상 재할당 된다.
    // (객체가 가진 값은 그대로 이지만, 객체의 참조값이 바뀌기 때문)
    // - 이 문제를 해결하기 위해서 객체의 참조값을 useMemo()를 이용해 캐싱해 둔다.

    // Object Type Problem이 발생하는 객체 tv
    /*
      const tv = {
      brand: 'samsung',
      size: 75,
      price: sale ? '할인가' : '정상가',
    }
    */

    // useMemo()를 이용해 객체 tv의 참조값을 캐싱해 두기
    const tv = React.useMemo(() => {
      return {
        brand: 'samsung',
        size: 75,
        price: sale ? '할인가' : '정상가',
      }
    }, [sale]);  // sale이 변하면 객체 tv를 다시 생성 하고, 아니면 캐싱(저장)해 둔 객체 tv를 사용한다

    // useEffect
    React.useEffect(() => {
      console.log(tv);
    }, [tv])  // tv가 변하면 useEffect의 콜백 함수가 동작 한다.

    // return
    return (
      <>
        <button onClick={e => setSale(!sale)}>할인변경</button>
        <bt/>
        <input type="number" value={number} onChange={e => setNumber(e.target.value)}/>
      </>
    )
  }

  ReactDOM.createRoot(document.getElementById('root3')).render(<ObjectTypeProblem/>)
</script>
</body>
</html>